-- package com.gelov.sync.db

CREATE TABLE outbox (
  outboxId INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
  entity TEXT NOT NULL,
  recordId TEXT NOT NULL,
  op TEXT NOT NULL,
  payloadJson TEXT,
  clientUpdatedAt TEXT NOT NULL,
  originClientId TEXT NOT NULL,
  status TEXT NOT NULL,            -- 'PENDING' | 'ACKED' | 'FAILED' | 'DEAD'
  attemptCount INTEGER NOT NULL DEFAULT 0,
  lastError TEXT,
  createdAt TEXT NOT NULL,
  changeId TEXT NOT NULL,
  nextAttemptAt TEXT              -- ISO Instant, null = sofort
);

CREATE INDEX outbox_status_idx ON outbox(status, createdAt);
CREATE INDEX outbox_entity_record_idx ON outbox(entity, recordId);
CREATE UNIQUE INDEX IF NOT EXISTS idx_outbox_changeId ON outbox(changeId);
CREATE INDEX IF NOT EXISTS idx_outbox_pending_record ON outbox(entity, recordId, status);

CREATE TABLE cursor_state (
  id INTEGER NOT NULL PRIMARY KEY CHECK (id = 1),
  cursor INTEGER NOT NULL
);

initCursorRow:
INSERT OR IGNORE INTO cursor_state(id, cursor) VALUES (1, 0);

getCursor:
SELECT cursor FROM cursor_state WHERE id = 1;

setCursor:
UPDATE cursor_state SET cursor = ? WHERE id = 1;

selectPending:
SELECT outboxId,
       entity,
       recordId,
       op,
       payloadJson,
       clientUpdatedAt,
       originClientId,
       changeId
FROM outbox
WHERE status = 'PENDING'
ORDER BY createdAt
LIMIT ?;

selectReady:
SELECT outboxId, entity, recordId, op, payloadJson, clientUpdatedAt, originClientId, changeId
FROM outbox
WHERE status IN ('PENDING', 'FAILED')
  AND (
    status = 'PENDING'
    OR nextAttemptAt IS NULL
    OR nextAttemptAt <= ?
  )
ORDER BY createdAt
LIMIT ?;

selectAllOutbox:
SELECT
  outboxId,
  entity,
  recordId,
  op,
  status,
  attemptCount,
  lastError,
  nextAttemptAt,
  clientUpdatedAt,
  changeId
FROM outbox
ORDER BY outboxId;

markAcked:
UPDATE outbox
SET status = 'ACKED'
WHERE outboxId IN ?;

markFailed:
UPDATE outbox
SET
  status = CASE WHEN attemptCount + 1 >= ? THEN 'DEAD' ELSE 'FAILED' END,
  attemptCount = attemptCount + 1,
  lastError = ?,
  nextAttemptAt = ?
WHERE outboxId = ?;

markAckedByChangeIds:
UPDATE outbox
SET status = 'ACKED'
WHERE changeId IN ?;

markFailedByChangeId:
UPDATE outbox
SET status = 'FAILED',
    attemptCount = attemptCount + 1,
    lastError = ?
WHERE changeId = ?;

hasPending:
SELECT EXISTS(
  SELECT 1 FROM outbox WHERE status = 'PENDING' LIMIT 1
);

-- latest pending for one record
selectPendingForRecord:
SELECT *
FROM outbox
WHERE entity = ? AND recordId = ? AND status = 'PENDING'
ORDER BY clientUpdatedAt DESC, originClientId DESC, outboxId DESC
LIMIT 1;

-- update existing pending (stable outboxId)
updatePendingOutboxById:
UPDATE outbox
SET
  op = ?,
  payloadJson = ?,
  clientUpdatedAt = ?,
  originClientId = ?,
  status = 'PENDING',
  attemptCount = 0,
  lastError = NULL
WHERE outboxId = ?;

-- insert new pending
insertPendingOutbox:
INSERT INTO outbox(
  entity, recordId, op, payloadJson,
  clientUpdatedAt, originClientId,
  status, createdAt, changeId, nextAttemptAt
) VALUES (?, ?, ?, ?, ?, ?, 'PENDING', ?, ?, NULL);

-- ----------------------------
-- Key/Value Store (Client Meta)
-- ----------------------------
CREATE TABLE IF NOT EXISTS sync_kv (
  key TEXT NOT NULL PRIMARY KEY,
  value TEXT
);

upsertKv:
INSERT OR REPLACE INTO sync_kv(key, value)
VALUES (?, ?);


getKv:
SELECT value AS v FROM sync_kv WHERE key = ?;


deleteKv:
DELETE FROM sync_kv WHERE key = ?;
